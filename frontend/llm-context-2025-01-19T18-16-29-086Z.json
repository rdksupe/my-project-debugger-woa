{
  "files": [
    {
      "name": "src/cli/index.ts",
      "content": "#!/usr/bin/env node\n\nimport { Command } from 'commander';\nimport inquirer from 'inquirer';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport chalk from 'chalk';\nimport axios from 'axios';\nimport { glob } from 'glob';\nimport { promisify } from 'util';\nimport { ProjectContextGatherer } from '../utils/ProjectContextGatherer';\nimport { writeFile } from 'fs/promises';\n// Type definitions\n\ninterface AnalysisContext {\n  files: FileContent[];\n  errorLog: string;\n  stackTrace: ParsedStackTrace;\n  projectContext: string;\n  timestamp: string;\n}\n\ninterface FileContent {\n  name: string;\n  content: string;\n}\n\ninterface LLMResponse {\n  answer: string;\n  model: string;\n  usage?: {\n    prompt_tokens: number;\n    completion_tokens: number;\n    total_tokens: number;\n  };\n}\n\ninterface APIResponse {\n  success?: boolean;  // Made optional since it's not in the response\n  code?: number;      // Made optional since it's not in the response\n  answer: string;     // Direct properties from the response\n  model: string;\n  usage?: {\n    prompt_tokens: number;\n    completion_tokens: number;\n    total_tokens: number;\n  };\n}\n\n// Update the ChalkColor type to match chalk's actual color methods\ntype ChalkColor = 'black' | 'red' | 'green' | 'yellow' | 'blue' | 'magenta' | 'cyan' | 'white' | 'gray' | 'grey';\n\ninterface DisplayOptions {\n  wrapWidth?: number;\n  codeBlockColor?: ChalkColor;\n  textColor?: ChalkColor;\n}\n\n// Constants\nconst DEFAULT_API_URL = 'http://localhost:3000/api/code/context';\nconst DEFAULT_FILE_PATTERNS = ['**/*.{ts,js,tsx,jsx,json,md,py,java,cpp,c,h,hpp,cs,go,rs,rb}'];\nconst IGNORE_PATTERNS = [\n  '**/node_modules/**',\n  '**/dist/**',\n  '**/.git/**',\n  '**/build/**',\n  '**/.cache/**',\n  '**/coverage/**'\n];\ninterface StackTraceFrame {\n  fileName?: string;\n  lineNumber?: number;\n  columnNumber?: number;\n  functionName?: string;\n  methodName?: string;\n  className?: string;\n  isNative?: boolean;\n  isConstructor?: boolean;\n  fileRelativePath?: string;\n  rawLine: string;\n}\n\ninterface ParsedStackTrace {\n  message: string;\n  type?: string;\n  frames: StackTraceFrame[];\n  rawStack: string;\n}\n\n// Add these constants for stack trace parsing\nconst STACK_TRACE_PATTERNS = {\n  // Node.js/V8 style\n  nodeStyle: /at\\s+(?:(?<functionName>[^(]+)?\\s+)?\\(?(?<fileInfo>(?<fileName>[^:]+):(?<lineNumber>\\d+):(?<columnNumber>\\d+))?\\)?/,\n  \n  // Browser style\n  browserStyle: /(?<functionName>[^@]*)@(?<fileName>[^:]+):(?<lineNumber>\\d+):(?<columnNumber>\\d+)/,\n  \n  // Java/JVM style\n  javaStyle: /at\\s+(?<className>[\\w$\\.]+)\\.(?<methodName>[\\w$]+)\\((?<fileName>[\\w$\\.]+):(?<lineNumber>\\d+)\\)/,\n  \n  // Python style\n  pythonStyle: /File\\s+\"(?<fileName>[^\"]+)\",\\s+line\\s+(?<lineNumber>\\d+),\\s+in\\s+(?<functionName>\\w+)/,\n  \n  // Common error message pattern\n  errorMessage: /(?<type>[\\w$\\.]+Error):\\s+(?<message>.*)/\n};\n\n// Add these helper functions for stack trace parsing\nfunction parseStackTrace(errorLog: string): ParsedStackTrace {\n  const lines = errorLog.trim().split('\\n').map(line => line.trim());\n  const frames: StackTraceFrame[] = [];\n  let message = '';\n  let type = '';\n\n  // Try to extract error type and message from the first line\n  const errorMatch = lines[0].match(STACK_TRACE_PATTERNS.errorMessage);\n  if (errorMatch?.groups) {\n    type = errorMatch.groups.type;\n    message = errorMatch.groups.message;\n  } else {\n    message = lines[0];\n  }\n\n  // Process each line of the stack trace\n  for (const line of lines.slice(1)) {\n    let frame: Partial<StackTraceFrame> = { rawLine: line };\n    let matched = false;\n\n    // Try each pattern\n    for (const [style, pattern] of Object.entries(STACK_TRACE_PATTERNS)) {\n      if (style === 'errorMessage') continue;\n\n      const match = line.match(pattern);\n      if (match?.groups) {\n        matched = true;\n        frame = {\n          ...frame,\n          ...match.groups,\n          lineNumber: match.groups.lineNumber ? parseInt(match.groups.lineNumber, 10) : undefined,\n          columnNumber: match.groups.columnNumber ? parseInt(match.groups.columnNumber, 10) : undefined\n        };\n\n        // Process function name for constructor calls\n        if (frame.functionName) {\n          frame.isConstructor = frame.functionName.includes('new ');\n          frame.functionName = frame.functionName.replace('new ', '').trim();\n        }\n\n        // Process file paths\n        if (frame.fileName) {\n          frame.isNative = frame.fileName.includes('native');\n          frame.fileRelativePath = path.relative(process.cwd(), frame.fileName);\n        }\n\n        break;\n      }\n    }\n\n    if (matched && frame.fileName) {\n      frames.push(frame as StackTraceFrame);\n    }\n  }\n\n  return {\n    message,\n    type,\n    frames,\n    rawStack: errorLog\n  };\n}\nasync function prepareAnalysisContext(\n  files: FileContent[],\n  errorLog: string,\n  stackTrace: ParsedStackTrace,\n  directory: string\n): Promise<AnalysisContext> {\n  try {\n    const contextGatherer = new ProjectContextGatherer(directory);\n    const projectContext = await contextGatherer.formatForLLM();\n\n    return {\n      files,\n      errorLog,\n      stackTrace,\n      projectContext,\n      timestamp: new Date().toISOString()\n    };\n  } catch (error) {\n    console.error(chalk.yellow('Warning: Error gathering project context:'), error);\n    // Return basic context if project context gathering fails\n    return {\n      files,\n      errorLog,\n      stackTrace,\n      projectContext: 'Project context gathering failed',\n      timestamp: new Date().toISOString()\n    };\n  }\n}\n\n// Add this function to analyze stack trace and find relevant files\nasync function analyzeStackTrace(\n  stackTrace: ParsedStackTrace,\n  baseDir: string\n): Promise<Set<string>> {\n  const relevantFiles = new Set<string>();\n  const filePatterns = new Set<string>();\n\n  // Extract file patterns from stack trace\n  for (const frame of stackTrace.frames) {\n    if (frame.fileName) {\n      const fileName = path.basename(frame.fileName);\n      const fileNameWithoutExt = path.parse(fileName).name;\n      \n      // Add exact file name\n      filePatterns.add(`**/${fileName}`);\n      \n      // Add pattern for files with different extensions\n      filePatterns.add(`**/${fileNameWithoutExt}.*`);\n\n      // If it's a TypeScript error, also look for related definition files\n      if (fileName.endsWith('.ts') || fileName.endsWith('.tsx')) {\n        filePatterns.add(`**/${fileNameWithoutExt}.d.ts`);\n      }\n\n      // If it's a compiled file, look for source files\n      if (fileName.endsWith('.js')) {\n        filePatterns.add(`**/${fileNameWithoutExt}.ts`);\n        filePatterns.add(`**/${fileNameWithoutExt}.tsx`);\n      }\n    }\n  }\n\n  // Find files matching the patterns\n  try {\n    const files = await glob(Array.from(filePatterns), {\n      cwd: baseDir,\n      ignore: IGNORE_PATTERNS,\n      absolute: true,\n      nodir: true\n    });\n\n    files.forEach(file => relevantFiles.add(file));\n  } catch (error) {\n    console.error(chalk.yellow('Error finding related files:', error));\n  }\n\n  return relevantFiles;\n}\n\n// Add this function to get context around error lines\nasync function getErrorContext(\n  filePath: string,\n  lineNumber: number,\n  contextLines: number = 5\n): Promise<string> {\n  try {\n    const content = await fs.readFile(filePath, 'utf-8');\n    const lines = content.split('\\n');\n    const start = Math.max(0, lineNumber - contextLines - 1);\n    const end = Math.min(lines.length, lineNumber + contextLines);\n    \n    return lines\n      .slice(start, end)\n      .map((line, index) => {\n        const currentLineNumber = start + index + 1;\n        const isErrorLine = currentLineNumber === lineNumber;\n        return `${currentLineNumber.toString().padStart(4)} | ${\n          isErrorLine ? chalk.red(line) : line\n        }`;\n      })\n      .join('\\n');\n  } catch (error) {\n    return `Error reading file: ${error instanceof Error ? error.message : 'Unknown error'}`;\n  }\n}\n\n// Helper Functions\nfunction displayFormattedResponse(\n  response: APIResponse,\n  options: DisplayOptions = {}\n): void {\n  const {\n    wrapWidth = 80,\n    codeBlockColor = 'cyan',\n    textColor = 'white'\n  } = options;\n\n  // Helper function to safely apply chalk colors\n  const applyChalkColor = (text: string, color: ChalkColor): string => {\n    const chalkMethod = chalk[color];\n    return typeof chalkMethod === 'function' ? chalkMethod(text) : text;\n  };\n\n  try {\n    // First, display raw JSON in debug mode\n    console.log(chalk.yellow('\\nDebug: Raw Response:'));\n    console.log(chalk.gray('─'.repeat(wrapWidth)));\n    console.log(chalk.white(JSON.stringify(response, null, 2)));\n    console.log(chalk.gray('─'.repeat(wrapWidth)));\n\n    if (!response?.answer) {\n      throw new Error('Invalid response format: missing answer field');\n    }\n\n    const answer = response.answer.trim();\n    const metadata = response;\n\n    console.log('\\n' + chalk.green('Analysis Result:'));\n    console.log(chalk.gray('─'.repeat(wrapWidth)));\n\n    // Split the response into segments, preserving code blocks\n    const segments: string[] = answer.split(/(```[\\s\\S]*?```)/g);\n\n    segments.forEach((segment: string) => {\n      segment = segment.trim();\n      if (!segment) return;\n\n      if (segment.startsWith('```')) {\n        // Handle code blocks\n        const codeBlock = segment\n          .replace(/```(\\w+)?/, '')\n          .replace(/```$/, '')\n          .trim();\n        const language = segment.match(/```(\\w+)/)?.[1] || '';\n\n        console.log(chalk.yellow(`\\nCode${language ? ` (${language})` : ''}:`));\n        console.log(applyChalkColor(codeBlock, codeBlockColor));\n        console.log(); // Empty line after code block\n      } else {\n        // Handle regular text with proper word wrapping\n        const words = segment.split(/\\s+/);\n        let currentLine = '';\n\n        words.forEach((word: string) => {\n          if ((currentLine + ' ' + word).length <= wrapWidth) {\n            currentLine += (currentLine ? ' ' : '') + word;\n          } else {\n            if (currentLine) {\n              console.log(applyChalkColor(currentLine, textColor));\n            }\n            currentLine = word;\n          }\n        });\n\n        if (currentLine) {\n          console.log(applyChalkColor(currentLine, textColor));\n        }\n      }\n    });\n\n    console.log(chalk.gray('─'.repeat(wrapWidth)));\n\n    // Display metadata if available\n    if (metadata.model) {\n      console.log(chalk.gray(`\\nModel: ${metadata.model}`));\n    }\n\n    if (metadata.usage) {\n      console.log(chalk.gray('Usage Statistics:'));\n      console.log(chalk.gray(`  - Prompt Tokens: ${metadata.usage.prompt_tokens}`));\n      console.log(chalk.gray(`  - Completion Tokens: ${metadata.usage.completion_tokens}`));\n      console.log(chalk.gray(`  - Total Tokens: ${metadata.usage.total_tokens}`));\n    }\n  } catch (error) {\n    // Display parsing error details\n    console.error(chalk.red('\\nError parsing response:'));\n    console.error(chalk.red(error instanceof Error ? error.message : 'Unknown error'));\n    \n    console.log(chalk.yellow('\\nAttempting to display raw response data:'));\n    console.log(chalk.gray('─'.repeat(wrapWidth)));\n    \n    try {\n      // Try different ways to display the response data\n      if (typeof response === 'string') {\n        console.log(chalk.white(response));\n      } else if (response instanceof Buffer) {\n        console.log(chalk.white(response.toString()));\n      } else {\n        console.log(chalk.white(JSON.stringify(response, null, 2)));\n      }\n    } catch (displayError) {\n      console.error(chalk.red('\\nFailed to stringify response:'));\n      console.error(chalk.red(displayError instanceof Error ? displayError.message : 'Unknown error'));\n      console.log(chalk.white(response));\n    }\n    \n    console.log(chalk.gray('─'.repeat(wrapWidth)));\n  }\n}\n\nasync function getFilesFromDirectory(directory: string): Promise<string[]> {\n  try {\n    const files = await glob(DEFAULT_FILE_PATTERNS, {\n      cwd: directory,\n      ignore: IGNORE_PATTERNS,\n      absolute: true,\n      nodir: true\n    });\n    return files;\n  } catch (error) {\n    console.error(chalk.red('Error scanning directory:', error));\n    return [];\n  }\n}\n\nasync function readFileContent(filePath: string): Promise<string> {\n  try {\n    const absolutePath = path.resolve(process.cwd(), filePath);\n    return await fs.readFile(absolutePath, 'utf-8');\n  } catch (error) {\n    console.error(chalk.red(`Error reading file ${filePath}:`, error));\n    throw error;\n  }\n}\n\n// Add new helper function\nasync function saveContextToFile(\n  context: any,\n  directory: string,\n  prefix: string = 'llm-context'\n): Promise<string> {\n  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n  const filename = `${prefix}-${timestamp}.json`;\n  const filepath = path.join(directory, filename);\n\n  try {\n    await writeFile(\n      filepath,\n      JSON.stringify(context, null, 2),\n      'utf-8'\n    );\n    return filepath;\n  } catch (error) {\n    console.error(chalk.red('Error saving context to file:'), error);\n    throw error;\n  }\n}\n\nasync function sendToLLM(\n  files: FileContent[],\n  errorLog: string,\n  prompt?: string,\n  saveContext: boolean = false\n): Promise<APIResponse> {\n  try {\n    // Parse stack trace from error log\n    const stackTrace = parseStackTrace(errorLog);\n    \n    // Prepare analysis context with project information\n    const analysisContext = await prepareAnalysisContext(\n      files,\n      errorLog,\n      stackTrace,\n      process.cwd()\n    );\n\n    const requestPayload = {\n      files,\n      errorLog,\n      analysisContext,\n      prompt: prompt || \"Please analyze the code and error log, and explain what might be wrong.\"\n    };\n\n    // Save context if requested\n    if (saveContext) {\n      try {\n        const savedPath = await saveContextToFile(requestPayload, process.cwd());\n        console.log(chalk.green('\\nContext saved to:'), chalk.cyan(savedPath));\n      } catch (error) {\n        console.error(chalk.yellow('Warning: Failed to save context file'), error);\n      }\n    }\n\n    const response = await axios.post<APIResponse>(DEFAULT_API_URL, requestPayload);\n\n    // Debug logging\n    console.log(chalk.yellow('\\nDebug: API Response Structure:'));\n    console.log(JSON.stringify(response.data, null, 2));\n\n    // Verify the response has the required fields\n    if (!response.data.answer || !response.data.model) {\n      throw new Error('Invalid API response structure');\n    }\n\n    return response.data;\n  } catch (error) {\n    // Enhanced error logging\n    console.error(chalk.red('\\nDetailed Error Information:'));\n    if (error instanceof Error && error.message.includes('ProjectContextGatherer')) {\n      console.error(chalk.yellow('Error gathering project context:'), error.message);\n    } else if (axios.isAxiosError(error)) {\n      console.error(chalk.red(`Status: ${error.response?.status || 'unknown'}`));\n      console.error(chalk.red(`Message: ${error.message}`));\n      if (error.response?.data) {\n        console.error(chalk.yellow('\\nResponse Data:'));\n        console.error(JSON.stringify(error.response.data, null, 2));\n      }\n    } else {\n      console.error(chalk.red(error instanceof Error ? error.message : 'Unknown error'));\n    }\n    throw error;\n  }\n}\n\n// Add new helper function\nasync function printProjectContext(directory: string, debug: boolean = false): Promise<void> {\n  try {\n    console.log(chalk.blue('\\nGathering Project Context...'));\n    const gatherer = new ProjectContextGatherer(directory);\n    const context = await gatherer.formatForLLM();\n    \n    console.log(chalk.gray('─'.repeat(80)));\n    console.log(context);\n    console.log(chalk.gray('─'.repeat(80)));\n\n    if (debug) {\n      const rawInfo = await gatherer.gatherEnvironmentInfo();\n      console.log(chalk.yellow('\\nDebug: Raw Project Information:'));\n      console.log(JSON.stringify(rawInfo, null, 2));\n    }\n  } catch (error) {\n    console.error(chalk.red('Error gathering project context:'), error);\n    throw error;\n  }\n}\n\n// Main CLI Application\nasync function main() {\n  const program = new Command();\n\n  program\n    .name('code-help')\n    .description('CLI tool to get AI help with code issues')\n    .version('1.1.0.1');\n\n  // Add new command for context\n  program\n    .command('context')\n    .description('Display project context information')\n    .option('-d, --directory <path>', 'Specify directory to scan', process.cwd())\n    .option('--debug', 'Show raw context data', false)\n    .action(async (options) => {\n      try {\n        await printProjectContext(options.directory, options.debug);\n      } catch (error) {\n        console.error(chalk.red('Error:'), error);\n        process.exit(1);\n      }\n    });\n\n  program\n    .command('analyze')\n    .description('Analyze code files and error logs')\n    .option('-d, --directory <path>', 'Specify directory to scan', process.cwd())\n    .option('-p, --pattern <pattern>', 'File pattern to match')\n    .option('--debug', 'Enable debug mode', false)\n    .option('--save-context', 'Save the analysis context to a file', false)\n    .action(async (options) => {\n      try {\n        console.log(chalk.blue('\\nCode Analysis Helper'));\n        console.log(chalk.blue('===================\\n'));\n\n        let files: FileContent[] = [];\n\n        // File Selection Method\n        const fileQuestions = await inquirer.prompt<{ fileSelection: 'scan' | 'manual' }>([\n          {\n            type: 'list',\n            name: 'fileSelection',\n            message: 'How would you like to add files?',\n            choices: [\n              { name: 'Scan current directory', value: 'scan' },\n              { name: 'Add files manually', value: 'manual' }\n            ]\n          }\n        ]);\n\n        if (fileQuestions.fileSelection === 'scan') {\n          const currentDir = options.directory || process.cwd();\n          console.log(chalk.blue(`\\nScanning directory: ${currentDir}`));\n          \n          const foundFiles = await getFilesFromDirectory(currentDir);\n          \n          if (foundFiles.length === 0) {\n            console.log(chalk.yellow('\\nNo matching files found in the directory.'));\n            return;\n          }\n\n          const fileSelection = await inquirer.prompt<{ selectedFiles: string[] }>([\n            {\n              type: 'checkbox',\n              name: 'selectedFiles',\n              message: 'Select files to analyze (use space to select):',\n              choices: foundFiles.map(file => ({\n                name: path.relative(currentDir, file),\n                value: file\n              })),\n              validate: (answer: string[]) => {\n                if (answer.length < 1) {\n                  return 'You must choose at least one file.';\n                }\n                return true;\n              }\n            }\n          ]);\n\n          for (const file of fileSelection.selectedFiles) {\n            const content = await readFileContent(file);\n            files.push({\n              name: path.relative(currentDir, file),\n              content\n            });\n          }\n        } else {\n          // Manual file addition\n          let addMoreFiles = true;\n          while (addMoreFiles) {\n            const fileAnswers = await inquirer.prompt<{ filePath: string }>([\n              {\n                type: 'input',\n                name: 'filePath',\n                message: 'Enter the path to the file:',\n                validate: async (input: string) => {\n                  try {\n                    await fs.access(path.resolve(process.cwd(), input));\n                    return true;\n                  } catch {\n                    return 'File does not exist!';\n                  }\n                }\n              }\n            ]);\n\n            const content = await readFileContent(fileAnswers.filePath);\n            files.push({\n              name: path.basename(fileAnswers.filePath),\n              content\n            });\n\n            const moreFiles = await inquirer.prompt<{ add: boolean }>([\n              {\n                type: 'confirm',\n                name: 'add',\n                message: 'Would you like to add another file?',\n                default: false\n              }\n            ]);\n\n            addMoreFiles = moreFiles.add;\n          }\n        }\n\n        // Error Log Input\n        const errorLogQuestions = await inquirer.prompt<{ errorLog: string }>([\n          {\n            type: 'editor',\n            name: 'errorLog',\n            message: 'Please paste your error log (press i to start editing, ESC then :wq to save):',\n            default: ''\n          }\n        ]);\n\n        // Optional Question Input\n\n\n\n        const stackTrace = parseStackTrace(errorLogQuestions.errorLog);\n\n      \n        if (options.debug) {\n          console.log(chalk.yellow('\\nParsed Stack Trace:'));\n          console.log(JSON.stringify(stackTrace, null, 2));\n        }\n  \n        console.log(chalk.blue('\\nError Analysis:'));\n        console.log(chalk.red(`Error: ${stackTrace.type || 'Unknown Error'}`));\n        console.log(chalk.red(`Message: ${stackTrace.message}`));\n  \n        // Find relevant files\n        const relevantFiles = await analyzeStackTrace(stackTrace, options.directory);\n  \n        if (relevantFiles.size > 0) {\n          console.log(chalk.yellow('\\nRelevant files found:'));\n          for (const file of relevantFiles) {\n            console.log(chalk.cyan(`- ${path.relative(options.directory, file)}`));\n          }\n  \n          // Show context for error locations\n          console.log(chalk.yellow('\\nError context:'));\n          for (const frame of stackTrace.frames) {\n            if (frame.fileName && frame.lineNumber) {\n              const filePath = path.resolve(options.directory, frame.fileName);\n              if (await fs.access(filePath).then(() => true).catch(() => false)) {\n                console.log(chalk.cyan(`\\nIn ${frame.fileName}:`));\n                console.log(await getErrorContext(filePath, frame.lineNumber));\n              }\n            }\n          }\n  \n          // Ask user which files to include\n          const fileSelection = await inquirer.prompt<{ selectedFiles: string[] }>([\n            {\n              type: 'checkbox',\n              name: 'selectedFiles',\n              message: 'Select files to include in analysis:',\n              choices: Array.from(relevantFiles).map(file => ({\n                name: path.relative(options.directory, file),\n                value: file,\n                checked: true\n              }))\n            }\n          ]);\n  \n          // Add selected files to analysis\n          for (const file of fileSelection.selectedFiles) {\n            const content = await readFileContent(file);\n            files.push({\n              name: path.relative(options.directory, file),\n              content\n            });\n          }\n        }\n\n\n\n        const promptQuestions = await inquirer.prompt<{ hasPrompt: boolean; prompt?: string }>([\n          {\n            type: 'confirm',\n            name: 'hasPrompt',\n            message: 'Would you like to add a specific question?',\n            default: false\n          },\n          {\n            type: 'input',\n            name: 'prompt',\n            message: 'Enter your question:',\n            when: (answers) => answers.hasPrompt\n          }\n        ]);\n        // Show Summary\n        console.log(chalk.yellow('\\nAnalysis Summary:'));\n        console.log('─'.repeat(50));\n        console.log(chalk.white('Files to analyze:'));\n        files.forEach(f => console.log(chalk.cyan(`- ${f.name}`)));\n        console.log(chalk.white(`\\nError log size: ${errorLogQuestions.errorLog.length} characters`));\n        if (promptQuestions.prompt) {\n          console.log(chalk.white(`Question: ${promptQuestions.prompt}`));\n        }\n        console.log('─'.repeat(50));\n\n        // Confirmation\n        const confirm = await inquirer.prompt<{ proceed: boolean }>([\n          {\n            type: 'confirm',\n            name: 'proceed',\n            message: 'Would you like to proceed with the analysis?',\n            default: true\n          }\n        ]);\n\n        if (!confirm.proceed) {\n          console.log(chalk.yellow('\\nOperation cancelled'));\n          return;\n        }\n\n        // Show Progress\n        console.log(chalk.blue('\\nSending request to AI...'));\n\n        try {\n          // Call API and handle response\n          const response = await sendToLLM(\n            files,\n            errorLogQuestions.errorLog,\n            promptQuestions.prompt,\n            options.saveContext  // Pass the save option\n          );\n\n          // Display the response with debug information\n          displayFormattedResponse(response, {\n            wrapWidth: 80,\n            codeBlockColor: 'cyan',\n            textColor: 'white'\n          });\n\n        } catch (error) {\n          if (options.debug) {\n            console.error(chalk.red('\\nDetailed Error Information:'));\n            console.error(error);\n          } else {\n            console.error(chalk.red('\\nError during analysis:'), error instanceof Error ? error.message : error);\n          }\n        }\n      } catch (error) {\n        console.error(chalk.red('Error during analysis:', error));\n        if (options.debug) {\n          console.error('\\nStack trace:', error);\n        }\n      }\n    });\n\n  program.parse();\n}\n\n// Execute\nmain().catch((error) => {\n  console.error(chalk.red('Fatal Error:', error));\n  process.exit(1);\n});"
    }
  ],
  "errorLog": "AxiosError: Request failed with status code 503\n    at settle (/home/rdksupe/debug-terminal/node_modules/axios/dist/node/axios.cjs:2026:12)\n    at IncomingMessage.handleStreamEnd (/home/rdksupe/debug-terminal/node_modules/axios/dist/node/axios.cjs:3142:11)\n    at IncomingMessage.emit (node:events:525:35)\n    at endReadableNT (node:internal/streams/readable:1696:12)\n    at process.processTicksAndRejections (node:internal/process/task_queues:90:21)\n    at Axios.request (/home/rdksupe/debug-terminal/node_modules/axios/dist/node/axios.cjs:4252:41)\n    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)\n    at async sendToLLM (/home/rdksupe/debug-terminal/dist/cli/index.js:307:26)\n    at async Command.<anonymous> (/home/rdksupe/debug-terminal/dist/cli/index.js:575:34) {\n",
  "analysisContext": {
    "files": [
      {
        "name": "src/cli/index.ts",
        "content": "#!/usr/bin/env node\n\nimport { Command } from 'commander';\nimport inquirer from 'inquirer';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport chalk from 'chalk';\nimport axios from 'axios';\nimport { glob } from 'glob';\nimport { promisify } from 'util';\nimport { ProjectContextGatherer } from '../utils/ProjectContextGatherer';\nimport { writeFile } from 'fs/promises';\n// Type definitions\n\ninterface AnalysisContext {\n  files: FileContent[];\n  errorLog: string;\n  stackTrace: ParsedStackTrace;\n  projectContext: string;\n  timestamp: string;\n}\n\ninterface FileContent {\n  name: string;\n  content: string;\n}\n\ninterface LLMResponse {\n  answer: string;\n  model: string;\n  usage?: {\n    prompt_tokens: number;\n    completion_tokens: number;\n    total_tokens: number;\n  };\n}\n\ninterface APIResponse {\n  success?: boolean;  // Made optional since it's not in the response\n  code?: number;      // Made optional since it's not in the response\n  answer: string;     // Direct properties from the response\n  model: string;\n  usage?: {\n    prompt_tokens: number;\n    completion_tokens: number;\n    total_tokens: number;\n  };\n}\n\n// Update the ChalkColor type to match chalk's actual color methods\ntype ChalkColor = 'black' | 'red' | 'green' | 'yellow' | 'blue' | 'magenta' | 'cyan' | 'white' | 'gray' | 'grey';\n\ninterface DisplayOptions {\n  wrapWidth?: number;\n  codeBlockColor?: ChalkColor;\n  textColor?: ChalkColor;\n}\n\n// Constants\nconst DEFAULT_API_URL = 'http://localhost:3000/api/code/context';\nconst DEFAULT_FILE_PATTERNS = ['**/*.{ts,js,tsx,jsx,json,md,py,java,cpp,c,h,hpp,cs,go,rs,rb}'];\nconst IGNORE_PATTERNS = [\n  '**/node_modules/**',\n  '**/dist/**',\n  '**/.git/**',\n  '**/build/**',\n  '**/.cache/**',\n  '**/coverage/**'\n];\ninterface StackTraceFrame {\n  fileName?: string;\n  lineNumber?: number;\n  columnNumber?: number;\n  functionName?: string;\n  methodName?: string;\n  className?: string;\n  isNative?: boolean;\n  isConstructor?: boolean;\n  fileRelativePath?: string;\n  rawLine: string;\n}\n\ninterface ParsedStackTrace {\n  message: string;\n  type?: string;\n  frames: StackTraceFrame[];\n  rawStack: string;\n}\n\n// Add these constants for stack trace parsing\nconst STACK_TRACE_PATTERNS = {\n  // Node.js/V8 style\n  nodeStyle: /at\\s+(?:(?<functionName>[^(]+)?\\s+)?\\(?(?<fileInfo>(?<fileName>[^:]+):(?<lineNumber>\\d+):(?<columnNumber>\\d+))?\\)?/,\n  \n  // Browser style\n  browserStyle: /(?<functionName>[^@]*)@(?<fileName>[^:]+):(?<lineNumber>\\d+):(?<columnNumber>\\d+)/,\n  \n  // Java/JVM style\n  javaStyle: /at\\s+(?<className>[\\w$\\.]+)\\.(?<methodName>[\\w$]+)\\((?<fileName>[\\w$\\.]+):(?<lineNumber>\\d+)\\)/,\n  \n  // Python style\n  pythonStyle: /File\\s+\"(?<fileName>[^\"]+)\",\\s+line\\s+(?<lineNumber>\\d+),\\s+in\\s+(?<functionName>\\w+)/,\n  \n  // Common error message pattern\n  errorMessage: /(?<type>[\\w$\\.]+Error):\\s+(?<message>.*)/\n};\n\n// Add these helper functions for stack trace parsing\nfunction parseStackTrace(errorLog: string): ParsedStackTrace {\n  const lines = errorLog.trim().split('\\n').map(line => line.trim());\n  const frames: StackTraceFrame[] = [];\n  let message = '';\n  let type = '';\n\n  // Try to extract error type and message from the first line\n  const errorMatch = lines[0].match(STACK_TRACE_PATTERNS.errorMessage);\n  if (errorMatch?.groups) {\n    type = errorMatch.groups.type;\n    message = errorMatch.groups.message;\n  } else {\n    message = lines[0];\n  }\n\n  // Process each line of the stack trace\n  for (const line of lines.slice(1)) {\n    let frame: Partial<StackTraceFrame> = { rawLine: line };\n    let matched = false;\n\n    // Try each pattern\n    for (const [style, pattern] of Object.entries(STACK_TRACE_PATTERNS)) {\n      if (style === 'errorMessage') continue;\n\n      const match = line.match(pattern);\n      if (match?.groups) {\n        matched = true;\n        frame = {\n          ...frame,\n          ...match.groups,\n          lineNumber: match.groups.lineNumber ? parseInt(match.groups.lineNumber, 10) : undefined,\n          columnNumber: match.groups.columnNumber ? parseInt(match.groups.columnNumber, 10) : undefined\n        };\n\n        // Process function name for constructor calls\n        if (frame.functionName) {\n          frame.isConstructor = frame.functionName.includes('new ');\n          frame.functionName = frame.functionName.replace('new ', '').trim();\n        }\n\n        // Process file paths\n        if (frame.fileName) {\n          frame.isNative = frame.fileName.includes('native');\n          frame.fileRelativePath = path.relative(process.cwd(), frame.fileName);\n        }\n\n        break;\n      }\n    }\n\n    if (matched && frame.fileName) {\n      frames.push(frame as StackTraceFrame);\n    }\n  }\n\n  return {\n    message,\n    type,\n    frames,\n    rawStack: errorLog\n  };\n}\nasync function prepareAnalysisContext(\n  files: FileContent[],\n  errorLog: string,\n  stackTrace: ParsedStackTrace,\n  directory: string\n): Promise<AnalysisContext> {\n  try {\n    const contextGatherer = new ProjectContextGatherer(directory);\n    const projectContext = await contextGatherer.formatForLLM();\n\n    return {\n      files,\n      errorLog,\n      stackTrace,\n      projectContext,\n      timestamp: new Date().toISOString()\n    };\n  } catch (error) {\n    console.error(chalk.yellow('Warning: Error gathering project context:'), error);\n    // Return basic context if project context gathering fails\n    return {\n      files,\n      errorLog,\n      stackTrace,\n      projectContext: 'Project context gathering failed',\n      timestamp: new Date().toISOString()\n    };\n  }\n}\n\n// Add this function to analyze stack trace and find relevant files\nasync function analyzeStackTrace(\n  stackTrace: ParsedStackTrace,\n  baseDir: string\n): Promise<Set<string>> {\n  const relevantFiles = new Set<string>();\n  const filePatterns = new Set<string>();\n\n  // Extract file patterns from stack trace\n  for (const frame of stackTrace.frames) {\n    if (frame.fileName) {\n      const fileName = path.basename(frame.fileName);\n      const fileNameWithoutExt = path.parse(fileName).name;\n      \n      // Add exact file name\n      filePatterns.add(`**/${fileName}`);\n      \n      // Add pattern for files with different extensions\n      filePatterns.add(`**/${fileNameWithoutExt}.*`);\n\n      // If it's a TypeScript error, also look for related definition files\n      if (fileName.endsWith('.ts') || fileName.endsWith('.tsx')) {\n        filePatterns.add(`**/${fileNameWithoutExt}.d.ts`);\n      }\n\n      // If it's a compiled file, look for source files\n      if (fileName.endsWith('.js')) {\n        filePatterns.add(`**/${fileNameWithoutExt}.ts`);\n        filePatterns.add(`**/${fileNameWithoutExt}.tsx`);\n      }\n    }\n  }\n\n  // Find files matching the patterns\n  try {\n    const files = await glob(Array.from(filePatterns), {\n      cwd: baseDir,\n      ignore: IGNORE_PATTERNS,\n      absolute: true,\n      nodir: true\n    });\n\n    files.forEach(file => relevantFiles.add(file));\n  } catch (error) {\n    console.error(chalk.yellow('Error finding related files:', error));\n  }\n\n  return relevantFiles;\n}\n\n// Add this function to get context around error lines\nasync function getErrorContext(\n  filePath: string,\n  lineNumber: number,\n  contextLines: number = 5\n): Promise<string> {\n  try {\n    const content = await fs.readFile(filePath, 'utf-8');\n    const lines = content.split('\\n');\n    const start = Math.max(0, lineNumber - contextLines - 1);\n    const end = Math.min(lines.length, lineNumber + contextLines);\n    \n    return lines\n      .slice(start, end)\n      .map((line, index) => {\n        const currentLineNumber = start + index + 1;\n        const isErrorLine = currentLineNumber === lineNumber;\n        return `${currentLineNumber.toString().padStart(4)} | ${\n          isErrorLine ? chalk.red(line) : line\n        }`;\n      })\n      .join('\\n');\n  } catch (error) {\n    return `Error reading file: ${error instanceof Error ? error.message : 'Unknown error'}`;\n  }\n}\n\n// Helper Functions\nfunction displayFormattedResponse(\n  response: APIResponse,\n  options: DisplayOptions = {}\n): void {\n  const {\n    wrapWidth = 80,\n    codeBlockColor = 'cyan',\n    textColor = 'white'\n  } = options;\n\n  // Helper function to safely apply chalk colors\n  const applyChalkColor = (text: string, color: ChalkColor): string => {\n    const chalkMethod = chalk[color];\n    return typeof chalkMethod === 'function' ? chalkMethod(text) : text;\n  };\n\n  try {\n    // First, display raw JSON in debug mode\n    console.log(chalk.yellow('\\nDebug: Raw Response:'));\n    console.log(chalk.gray('─'.repeat(wrapWidth)));\n    console.log(chalk.white(JSON.stringify(response, null, 2)));\n    console.log(chalk.gray('─'.repeat(wrapWidth)));\n\n    if (!response?.answer) {\n      throw new Error('Invalid response format: missing answer field');\n    }\n\n    const answer = response.answer.trim();\n    const metadata = response;\n\n    console.log('\\n' + chalk.green('Analysis Result:'));\n    console.log(chalk.gray('─'.repeat(wrapWidth)));\n\n    // Split the response into segments, preserving code blocks\n    const segments: string[] = answer.split(/(```[\\s\\S]*?```)/g);\n\n    segments.forEach((segment: string) => {\n      segment = segment.trim();\n      if (!segment) return;\n\n      if (segment.startsWith('```')) {\n        // Handle code blocks\n        const codeBlock = segment\n          .replace(/```(\\w+)?/, '')\n          .replace(/```$/, '')\n          .trim();\n        const language = segment.match(/```(\\w+)/)?.[1] || '';\n\n        console.log(chalk.yellow(`\\nCode${language ? ` (${language})` : ''}:`));\n        console.log(applyChalkColor(codeBlock, codeBlockColor));\n        console.log(); // Empty line after code block\n      } else {\n        // Handle regular text with proper word wrapping\n        const words = segment.split(/\\s+/);\n        let currentLine = '';\n\n        words.forEach((word: string) => {\n          if ((currentLine + ' ' + word).length <= wrapWidth) {\n            currentLine += (currentLine ? ' ' : '') + word;\n          } else {\n            if (currentLine) {\n              console.log(applyChalkColor(currentLine, textColor));\n            }\n            currentLine = word;\n          }\n        });\n\n        if (currentLine) {\n          console.log(applyChalkColor(currentLine, textColor));\n        }\n      }\n    });\n\n    console.log(chalk.gray('─'.repeat(wrapWidth)));\n\n    // Display metadata if available\n    if (metadata.model) {\n      console.log(chalk.gray(`\\nModel: ${metadata.model}`));\n    }\n\n    if (metadata.usage) {\n      console.log(chalk.gray('Usage Statistics:'));\n      console.log(chalk.gray(`  - Prompt Tokens: ${metadata.usage.prompt_tokens}`));\n      console.log(chalk.gray(`  - Completion Tokens: ${metadata.usage.completion_tokens}`));\n      console.log(chalk.gray(`  - Total Tokens: ${metadata.usage.total_tokens}`));\n    }\n  } catch (error) {\n    // Display parsing error details\n    console.error(chalk.red('\\nError parsing response:'));\n    console.error(chalk.red(error instanceof Error ? error.message : 'Unknown error'));\n    \n    console.log(chalk.yellow('\\nAttempting to display raw response data:'));\n    console.log(chalk.gray('─'.repeat(wrapWidth)));\n    \n    try {\n      // Try different ways to display the response data\n      if (typeof response === 'string') {\n        console.log(chalk.white(response));\n      } else if (response instanceof Buffer) {\n        console.log(chalk.white(response.toString()));\n      } else {\n        console.log(chalk.white(JSON.stringify(response, null, 2)));\n      }\n    } catch (displayError) {\n      console.error(chalk.red('\\nFailed to stringify response:'));\n      console.error(chalk.red(displayError instanceof Error ? displayError.message : 'Unknown error'));\n      console.log(chalk.white(response));\n    }\n    \n    console.log(chalk.gray('─'.repeat(wrapWidth)));\n  }\n}\n\nasync function getFilesFromDirectory(directory: string): Promise<string[]> {\n  try {\n    const files = await glob(DEFAULT_FILE_PATTERNS, {\n      cwd: directory,\n      ignore: IGNORE_PATTERNS,\n      absolute: true,\n      nodir: true\n    });\n    return files;\n  } catch (error) {\n    console.error(chalk.red('Error scanning directory:', error));\n    return [];\n  }\n}\n\nasync function readFileContent(filePath: string): Promise<string> {\n  try {\n    const absolutePath = path.resolve(process.cwd(), filePath);\n    return await fs.readFile(absolutePath, 'utf-8');\n  } catch (error) {\n    console.error(chalk.red(`Error reading file ${filePath}:`, error));\n    throw error;\n  }\n}\n\n// Add new helper function\nasync function saveContextToFile(\n  context: any,\n  directory: string,\n  prefix: string = 'llm-context'\n): Promise<string> {\n  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n  const filename = `${prefix}-${timestamp}.json`;\n  const filepath = path.join(directory, filename);\n\n  try {\n    await writeFile(\n      filepath,\n      JSON.stringify(context, null, 2),\n      'utf-8'\n    );\n    return filepath;\n  } catch (error) {\n    console.error(chalk.red('Error saving context to file:'), error);\n    throw error;\n  }\n}\n\nasync function sendToLLM(\n  files: FileContent[],\n  errorLog: string,\n  prompt?: string,\n  saveContext: boolean = false\n): Promise<APIResponse> {\n  try {\n    // Parse stack trace from error log\n    const stackTrace = parseStackTrace(errorLog);\n    \n    // Prepare analysis context with project information\n    const analysisContext = await prepareAnalysisContext(\n      files,\n      errorLog,\n      stackTrace,\n      process.cwd()\n    );\n\n    const requestPayload = {\n      files,\n      errorLog,\n      analysisContext,\n      prompt: prompt || \"Please analyze the code and error log, and explain what might be wrong.\"\n    };\n\n    // Save context if requested\n    if (saveContext) {\n      try {\n        const savedPath = await saveContextToFile(requestPayload, process.cwd());\n        console.log(chalk.green('\\nContext saved to:'), chalk.cyan(savedPath));\n      } catch (error) {\n        console.error(chalk.yellow('Warning: Failed to save context file'), error);\n      }\n    }\n\n    const response = await axios.post<APIResponse>(DEFAULT_API_URL, requestPayload);\n\n    // Debug logging\n    console.log(chalk.yellow('\\nDebug: API Response Structure:'));\n    console.log(JSON.stringify(response.data, null, 2));\n\n    // Verify the response has the required fields\n    if (!response.data.answer || !response.data.model) {\n      throw new Error('Invalid API response structure');\n    }\n\n    return response.data;\n  } catch (error) {\n    // Enhanced error logging\n    console.error(chalk.red('\\nDetailed Error Information:'));\n    if (error instanceof Error && error.message.includes('ProjectContextGatherer')) {\n      console.error(chalk.yellow('Error gathering project context:'), error.message);\n    } else if (axios.isAxiosError(error)) {\n      console.error(chalk.red(`Status: ${error.response?.status || 'unknown'}`));\n      console.error(chalk.red(`Message: ${error.message}`));\n      if (error.response?.data) {\n        console.error(chalk.yellow('\\nResponse Data:'));\n        console.error(JSON.stringify(error.response.data, null, 2));\n      }\n    } else {\n      console.error(chalk.red(error instanceof Error ? error.message : 'Unknown error'));\n    }\n    throw error;\n  }\n}\n\n// Add new helper function\nasync function printProjectContext(directory: string, debug: boolean = false): Promise<void> {\n  try {\n    console.log(chalk.blue('\\nGathering Project Context...'));\n    const gatherer = new ProjectContextGatherer(directory);\n    const context = await gatherer.formatForLLM();\n    \n    console.log(chalk.gray('─'.repeat(80)));\n    console.log(context);\n    console.log(chalk.gray('─'.repeat(80)));\n\n    if (debug) {\n      const rawInfo = await gatherer.gatherEnvironmentInfo();\n      console.log(chalk.yellow('\\nDebug: Raw Project Information:'));\n      console.log(JSON.stringify(rawInfo, null, 2));\n    }\n  } catch (error) {\n    console.error(chalk.red('Error gathering project context:'), error);\n    throw error;\n  }\n}\n\n// Main CLI Application\nasync function main() {\n  const program = new Command();\n\n  program\n    .name('code-help')\n    .description('CLI tool to get AI help with code issues')\n    .version('1.1.0.1');\n\n  // Add new command for context\n  program\n    .command('context')\n    .description('Display project context information')\n    .option('-d, --directory <path>', 'Specify directory to scan', process.cwd())\n    .option('--debug', 'Show raw context data', false)\n    .action(async (options) => {\n      try {\n        await printProjectContext(options.directory, options.debug);\n      } catch (error) {\n        console.error(chalk.red('Error:'), error);\n        process.exit(1);\n      }\n    });\n\n  program\n    .command('analyze')\n    .description('Analyze code files and error logs')\n    .option('-d, --directory <path>', 'Specify directory to scan', process.cwd())\n    .option('-p, --pattern <pattern>', 'File pattern to match')\n    .option('--debug', 'Enable debug mode', false)\n    .option('--save-context', 'Save the analysis context to a file', false)\n    .action(async (options) => {\n      try {\n        console.log(chalk.blue('\\nCode Analysis Helper'));\n        console.log(chalk.blue('===================\\n'));\n\n        let files: FileContent[] = [];\n\n        // File Selection Method\n        const fileQuestions = await inquirer.prompt<{ fileSelection: 'scan' | 'manual' }>([\n          {\n            type: 'list',\n            name: 'fileSelection',\n            message: 'How would you like to add files?',\n            choices: [\n              { name: 'Scan current directory', value: 'scan' },\n              { name: 'Add files manually', value: 'manual' }\n            ]\n          }\n        ]);\n\n        if (fileQuestions.fileSelection === 'scan') {\n          const currentDir = options.directory || process.cwd();\n          console.log(chalk.blue(`\\nScanning directory: ${currentDir}`));\n          \n          const foundFiles = await getFilesFromDirectory(currentDir);\n          \n          if (foundFiles.length === 0) {\n            console.log(chalk.yellow('\\nNo matching files found in the directory.'));\n            return;\n          }\n\n          const fileSelection = await inquirer.prompt<{ selectedFiles: string[] }>([\n            {\n              type: 'checkbox',\n              name: 'selectedFiles',\n              message: 'Select files to analyze (use space to select):',\n              choices: foundFiles.map(file => ({\n                name: path.relative(currentDir, file),\n                value: file\n              })),\n              validate: (answer: string[]) => {\n                if (answer.length < 1) {\n                  return 'You must choose at least one file.';\n                }\n                return true;\n              }\n            }\n          ]);\n\n          for (const file of fileSelection.selectedFiles) {\n            const content = await readFileContent(file);\n            files.push({\n              name: path.relative(currentDir, file),\n              content\n            });\n          }\n        } else {\n          // Manual file addition\n          let addMoreFiles = true;\n          while (addMoreFiles) {\n            const fileAnswers = await inquirer.prompt<{ filePath: string }>([\n              {\n                type: 'input',\n                name: 'filePath',\n                message: 'Enter the path to the file:',\n                validate: async (input: string) => {\n                  try {\n                    await fs.access(path.resolve(process.cwd(), input));\n                    return true;\n                  } catch {\n                    return 'File does not exist!';\n                  }\n                }\n              }\n            ]);\n\n            const content = await readFileContent(fileAnswers.filePath);\n            files.push({\n              name: path.basename(fileAnswers.filePath),\n              content\n            });\n\n            const moreFiles = await inquirer.prompt<{ add: boolean }>([\n              {\n                type: 'confirm',\n                name: 'add',\n                message: 'Would you like to add another file?',\n                default: false\n              }\n            ]);\n\n            addMoreFiles = moreFiles.add;\n          }\n        }\n\n        // Error Log Input\n        const errorLogQuestions = await inquirer.prompt<{ errorLog: string }>([\n          {\n            type: 'editor',\n            name: 'errorLog',\n            message: 'Please paste your error log (press i to start editing, ESC then :wq to save):',\n            default: ''\n          }\n        ]);\n\n        // Optional Question Input\n\n\n\n        const stackTrace = parseStackTrace(errorLogQuestions.errorLog);\n\n      \n        if (options.debug) {\n          console.log(chalk.yellow('\\nParsed Stack Trace:'));\n          console.log(JSON.stringify(stackTrace, null, 2));\n        }\n  \n        console.log(chalk.blue('\\nError Analysis:'));\n        console.log(chalk.red(`Error: ${stackTrace.type || 'Unknown Error'}`));\n        console.log(chalk.red(`Message: ${stackTrace.message}`));\n  \n        // Find relevant files\n        const relevantFiles = await analyzeStackTrace(stackTrace, options.directory);\n  \n        if (relevantFiles.size > 0) {\n          console.log(chalk.yellow('\\nRelevant files found:'));\n          for (const file of relevantFiles) {\n            console.log(chalk.cyan(`- ${path.relative(options.directory, file)}`));\n          }\n  \n          // Show context for error locations\n          console.log(chalk.yellow('\\nError context:'));\n          for (const frame of stackTrace.frames) {\n            if (frame.fileName && frame.lineNumber) {\n              const filePath = path.resolve(options.directory, frame.fileName);\n              if (await fs.access(filePath).then(() => true).catch(() => false)) {\n                console.log(chalk.cyan(`\\nIn ${frame.fileName}:`));\n                console.log(await getErrorContext(filePath, frame.lineNumber));\n              }\n            }\n          }\n  \n          // Ask user which files to include\n          const fileSelection = await inquirer.prompt<{ selectedFiles: string[] }>([\n            {\n              type: 'checkbox',\n              name: 'selectedFiles',\n              message: 'Select files to include in analysis:',\n              choices: Array.from(relevantFiles).map(file => ({\n                name: path.relative(options.directory, file),\n                value: file,\n                checked: true\n              }))\n            }\n          ]);\n  \n          // Add selected files to analysis\n          for (const file of fileSelection.selectedFiles) {\n            const content = await readFileContent(file);\n            files.push({\n              name: path.relative(options.directory, file),\n              content\n            });\n          }\n        }\n\n\n\n        const promptQuestions = await inquirer.prompt<{ hasPrompt: boolean; prompt?: string }>([\n          {\n            type: 'confirm',\n            name: 'hasPrompt',\n            message: 'Would you like to add a specific question?',\n            default: false\n          },\n          {\n            type: 'input',\n            name: 'prompt',\n            message: 'Enter your question:',\n            when: (answers) => answers.hasPrompt\n          }\n        ]);\n        // Show Summary\n        console.log(chalk.yellow('\\nAnalysis Summary:'));\n        console.log('─'.repeat(50));\n        console.log(chalk.white('Files to analyze:'));\n        files.forEach(f => console.log(chalk.cyan(`- ${f.name}`)));\n        console.log(chalk.white(`\\nError log size: ${errorLogQuestions.errorLog.length} characters`));\n        if (promptQuestions.prompt) {\n          console.log(chalk.white(`Question: ${promptQuestions.prompt}`));\n        }\n        console.log('─'.repeat(50));\n\n        // Confirmation\n        const confirm = await inquirer.prompt<{ proceed: boolean }>([\n          {\n            type: 'confirm',\n            name: 'proceed',\n            message: 'Would you like to proceed with the analysis?',\n            default: true\n          }\n        ]);\n\n        if (!confirm.proceed) {\n          console.log(chalk.yellow('\\nOperation cancelled'));\n          return;\n        }\n\n        // Show Progress\n        console.log(chalk.blue('\\nSending request to AI...'));\n\n        try {\n          // Call API and handle response\n          const response = await sendToLLM(\n            files,\n            errorLogQuestions.errorLog,\n            promptQuestions.prompt,\n            options.saveContext  // Pass the save option\n          );\n\n          // Display the response with debug information\n          displayFormattedResponse(response, {\n            wrapWidth: 80,\n            codeBlockColor: 'cyan',\n            textColor: 'white'\n          });\n\n        } catch (error) {\n          if (options.debug) {\n            console.error(chalk.red('\\nDetailed Error Information:'));\n            console.error(error);\n          } else {\n            console.error(chalk.red('\\nError during analysis:'), error instanceof Error ? error.message : error);\n          }\n        }\n      } catch (error) {\n        console.error(chalk.red('Error during analysis:', error));\n        if (options.debug) {\n          console.error('\\nStack trace:', error);\n        }\n      }\n    });\n\n  program.parse();\n}\n\n// Execute\nmain().catch((error) => {\n  console.error(chalk.red('Fatal Error:', error));\n  process.exit(1);\n});"
      }
    ],
    "errorLog": "AxiosError: Request failed with status code 503\n    at settle (/home/rdksupe/debug-terminal/node_modules/axios/dist/node/axios.cjs:2026:12)\n    at IncomingMessage.handleStreamEnd (/home/rdksupe/debug-terminal/node_modules/axios/dist/node/axios.cjs:3142:11)\n    at IncomingMessage.emit (node:events:525:35)\n    at endReadableNT (node:internal/streams/readable:1696:12)\n    at process.processTicksAndRejections (node:internal/process/task_queues:90:21)\n    at Axios.request (/home/rdksupe/debug-terminal/node_modules/axios/dist/node/axios.cjs:4252:41)\n    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)\n    at async sendToLLM (/home/rdksupe/debug-terminal/dist/cli/index.js:307:26)\n    at async Command.<anonymous> (/home/rdksupe/debug-terminal/dist/cli/index.js:575:34) {\n",
    "stackTrace": {
      "message": "Request failed with status code 503",
      "type": "AxiosError",
      "frames": [
        {
          "rawLine": "at settle (/home/rdksupe/debug-terminal/node_modules/axios/dist/node/axios.cjs:2026:12)",
          "functionName": "settle",
          "fileInfo": "/home/rdksupe/debug-terminal/node_modules/axios/dist/node/axios.cjs:2026:12",
          "fileName": "/home/rdksupe/debug-terminal/node_modules/axios/dist/node/axios.cjs",
          "lineNumber": 2026,
          "columnNumber": 12,
          "isConstructor": false,
          "isNative": false,
          "fileRelativePath": "node_modules/axios/dist/node/axios.cjs"
        },
        {
          "rawLine": "at IncomingMessage.handleStreamEnd (/home/rdksupe/debug-terminal/node_modules/axios/dist/node/axios.cjs:3142:11)",
          "functionName": "IncomingMessage.handleStreamEnd",
          "fileInfo": "/home/rdksupe/debug-terminal/node_modules/axios/dist/node/axios.cjs:3142:11",
          "fileName": "/home/rdksupe/debug-terminal/node_modules/axios/dist/node/axios.cjs",
          "lineNumber": 3142,
          "columnNumber": 11,
          "isConstructor": false,
          "isNative": false,
          "fileRelativePath": "node_modules/axios/dist/node/axios.cjs"
        },
        {
          "rawLine": "at Axios.request (/home/rdksupe/debug-terminal/node_modules/axios/dist/node/axios.cjs:4252:41)",
          "functionName": "Axios.request",
          "fileInfo": "/home/rdksupe/debug-terminal/node_modules/axios/dist/node/axios.cjs:4252:41",
          "fileName": "/home/rdksupe/debug-terminal/node_modules/axios/dist/node/axios.cjs",
          "lineNumber": 4252,
          "columnNumber": 41,
          "isConstructor": false,
          "isNative": false,
          "fileRelativePath": "node_modules/axios/dist/node/axios.cjs"
        },
        {
          "rawLine": "at async sendToLLM (/home/rdksupe/debug-terminal/dist/cli/index.js:307:26)",
          "functionName": "async sendToLLM",
          "fileInfo": "/home/rdksupe/debug-terminal/dist/cli/index.js:307:26",
          "fileName": "/home/rdksupe/debug-terminal/dist/cli/index.js",
          "lineNumber": 307,
          "columnNumber": 26,
          "isConstructor": false,
          "isNative": false,
          "fileRelativePath": "dist/cli/index.js"
        },
        {
          "rawLine": "at async Command.<anonymous> (/home/rdksupe/debug-terminal/dist/cli/index.js:575:34) {",
          "functionName": "async Command.<anonymous>",
          "fileInfo": "/home/rdksupe/debug-terminal/dist/cli/index.js:575:34",
          "fileName": "/home/rdksupe/debug-terminal/dist/cli/index.js",
          "lineNumber": 575,
          "columnNumber": 34,
          "isConstructor": false,
          "isNative": false,
          "fileRelativePath": "dist/cli/index.js"
        }
      ],
      "rawStack": "AxiosError: Request failed with status code 503\n    at settle (/home/rdksupe/debug-terminal/node_modules/axios/dist/node/axios.cjs:2026:12)\n    at IncomingMessage.handleStreamEnd (/home/rdksupe/debug-terminal/node_modules/axios/dist/node/axios.cjs:3142:11)\n    at IncomingMessage.emit (node:events:525:35)\n    at endReadableNT (node:internal/streams/readable:1696:12)\n    at process.processTicksAndRejections (node:internal/process/task_queues:90:21)\n    at Axios.request (/home/rdksupe/debug-terminal/node_modules/axios/dist/node/axios.cjs:4252:41)\n    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)\n    at async sendToLLM (/home/rdksupe/debug-terminal/dist/cli/index.js:307:26)\n    at async Command.<anonymous> (/home/rdksupe/debug-terminal/dist/cli/index.js:575:34) {\n"
    },
    "projectContext": "\n# Project and Environment Context\nGenerated at: 2025-01-19T18:16:29.065Z\n\n## System Information\n- Platform: linux\n- Architecture: x64\n- Node Version: v23.3.0\n- CPU Cores: 12\n- Memory: 15GB total, 4GB free\n\n## Project Information\n- Project Path: /home/rdksupe/debug-terminal\n\n- Name: code-helper\n- Version: 1.0.0\n- Description: CLI tool for code assistance\n\n\n## Git Information\n\n- Current Branch: main\n- Latest Commit: null\n- Remote URL: null\n- Status: ?? .gitignore\n?? package.json\n?? src/\n?? tsconfig.json\n\n\n## Project Structure\n```\n├── dist\n    ├── cli\n    │   └── index.js\n    └── utils\n    │   ├── ProjectContextGatherer.js\n    │   ├── apiUtils.js\n    │   ├── displayUtils.js\n    │   ├── fileUtils.js\n    │   ├── stackTraceParser.js\n    │   └── types.js\n├── package-lock.json\n├── package.json\n├── src\n    ├── cli\n    │   └── index.ts\n    └── utils\n    │   ├── ProjectContextGatherer.ts\n    │   ├── apiUtils.ts\n    │   ├── displayUtils.ts\n    │   ├── fileUtils.ts\n    │   ├── stackTraceParser.ts\n    │   └── types.ts\n└── tsconfig.json\n\n```\n\n## Dependencies\n\n### Production Dependencies\n- @ast-grep/cli: ^0.33.1\n- axios: ^1.7.9\n- chalk: ^5.4.1\n- commander: ^11.1.0\n- glob: ^11.0.1\n- inquirer: ^9.3.7\n\n### Development Dependencies\n- @types/glob: ^8.1.0\n- @types/inquirer: ^9.0.7\n- @types/node: ^20.17.12\n- ts-node: ^10.9.2\n- typescript: ^5.7.3\n\n",
    "timestamp": "2025-01-19T18:16:29.086Z"
  },
  "prompt": "Please analyze the code and error log, and explain what might be wrong."
}